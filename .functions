#!/usr/bin/env bash
# shellcheck disable=SC2248,SC2086
function hex2rgb() {
	local hex r g b modifier
	modifier=38
	while (($# > 0)); do
		if [ "$1" = "-b" ]; then
			modifier=48
			shift
		fi
		if [ "$1" = "-f" ]; then
			modifier=38
			shift
		fi
		hex="${1:-000000}"
		[ "${hex:0:1}" = "#" ] && hex="${hex:1}"
		hex="${hex#"#"}"
		hex="$(echo -n "${hex-}" | grep -E '^([0-9A-Fa-f]{3,4}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$' 2>&1 || echo -n 000000)"
		printf -v r "%d" 0x"${hex:0:2}"
		printf -v g "%d" 0x"${hex:2:2}"
		printf -v b "%d" 0x"${hex:4:2}"
		printf '\033[%d;%d;%d;%d;%dm' ${modifier:-38} 2 $r $g $b
		shift 1
	done
}
function 2rgb() {
	local hex output clean_output flip
	if [ "$1" = "-b" ]; then {
		flip=1
		shift
	}; fi
	echo
	for hex in "$@"; do
		output=$(hex2rgb "$hex")
		clean_output="\\\033$(printf $output | tr -d '\033')"
		[ -n "$flip" ] && clean_output=${clean_output/'[38'/'[48'}
		echo -e "$output#${hex#\#}\033[0;2m  -->  \033[0${flip:+;7}m$output $clean_output  \033[0m${flip:+\033[2m  (bg) \033[0m}\n"
	done
}
function calc() {
	local result=""
	result="$(printf 'scale=10;%s\n' "$*" | bc --mathlib | tr -d '\\\n')"
	if [[ $result == *.* ]]; then
		printf "%s" "$result" | sed -e 's/^\./0./' \
			-e 's/^-\./-0./' \
			-e 's/0*$//;s/\.$//'
	else
		printf "%s" "$result"
	fi
	printf '\n'
}
function pbkey() {
	local key="${1:-id_rsa4096.pub}"
	cat ~/.ssh/$key | pbcopy | success "The key named '${key-}' was copied to your clipboard." && return 0
	return 1
}
if which jq >&/dev/null; then
	function jsons() {
		jq "${1:-.}" "${2:-'./*.json'}"
	}
	function pkgjson() {
		jq "${1:-.}" "${2:-./package.json}"
	}
fi
if which gh >&/dev/null; then
	function gists() {
		gh gist list -L "${1:-100}"
	}
	function gist() {
		if (($# > 0)); then
			gh gist "$@"
		else
			gh gist view
		fi
	}
fi
function commit() {
	git commit --gpg-sign "$@" 2> /dev/null || {
		(echo "" | gpg --clear-sign --pinentry-mode loopback > /dev/null) && status "important" "GPG is ready to sign commits. Attempting signature..." && git commit --gpg-sign "$@"
	}
}
alias "git-commit"="commit"
function status() {
	local label label_color message message_color
	label="${1:-error}"
	label_color='41;37'
	case "${1,,}" in
		ok | okay | success | complete)
			label_color='42;30'
			label="${1:-SUCCESS}"
			shift 1
			;;
		warn | warning | non-fatal | important)
			label_color='43;30'
			label="${1:-WARNING}"
			shift 1
			;;
		err | error | fatal | exception | throw)
			label_color='41;37'
			label="${1:-ERROR}"
			shift 1
			;;
		info | debug | notice | note | *)
			label_color='46;30'
			label="${1:-INFO}"
			shift 1
			;;
	esac
	message="$*"
	message_color='1;3'
	printf '\n\e[0;1;%sm %s \e[0;%sm %s\e[0m\n' "$label_color" "${label^^}" "$message_color" "${message:-An unknown error occurred.}"
	return $?
}
alias __status="status"
function mkd() {
	mkdir -p "$@"
	cd "$@" || exit
}
function tmpd() {
	local dir
	if [ $# -eq 0 ]; then
		dir=$(mktemp -d)
	else
		dir=$(mktemp -d -t "$1.XXXXXXXXXX")
	fi
	cd "$dir" || exit
}
function targz() {
	local tmpFile="${1%/}.tar"
	tar -cvf "$tmpFile" --exclude=".DS_Store" "$1" || return 1
	size=$(
		stat -f"%z" "$tmpFile" \
			2> /dev/null
		stat -c"%s" "$tmpFile" 2> /dev/null
	)
	local cmd=""
	if ((size < 52428800)) && hash zopfli 2> /dev/null; then
		cmd="zopfli"
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi
	echo "Compressing .tar using \`$cmd\`â€¦"
	"$cmd" -v "$tmpFile" || return 1
	[ -f "$tmpFile" ] && rm "$tmpFile"
	echo "$tmpFile.gz created successfully."
}
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbhLc
	else
		local arg=-shLc
	fi
	if [[ -n "$*" ]]; then
		du $arg -- "$@"
	else
		du $arg -- .[^.]* *
	fi
}
function gitdiff() {
	local DIFF_OPTIONS="--color=auto --side-by-side"
	if which git > /dev/null 2>&1; then
		git diff "$DIFF_OPTIONS" --no-index --color-words "$@"
	else
		diff "$DIFF_OPTIONS" --color-words "$@"
	fi
}
alias diff=gitdiff
function dataurl() {
	local nocopy mimeType charSet data
	nocopy=0
	mimeType="image/svg+xml"
	charSet="utf-8"
	[ "$1" = "-c" ] && {
		nocopy=1
		shift
	}
	if [[ -f $1 ]]; then
		mimeType=$(file -b --mime-type "$1")
	elif [[ -d $1 ]]; then
		echo "Cannot coerce a directory into a file." && return 1
	fi
	printf -v data "data:%s;%sbase64,%s" "${mimeType:-"text/plain"}" "${charSet:+"charset=$charSet;"}" "$(cat "$1" | base64 | tr -d '\n')"
	[ -z "$data" ] && {
		echo "Failed constructing the dataurl string."
		return 2
	}
	[ $nocopy = 1 ] && {
		echo -n "$data"
		return 0
	}
	echo -n "$data" | pbcopy 2> /dev/null && echo "Created dataurl and copied to clipboard."
}
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:$port/" &
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}
function gz() {
	local origsize gzipsize ratio
	origsize=$(wc -c < "$1")
	gzipsize=$(gzip -c "$1" | wc -c)
	ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
	printf 'orig: %d bytes\n' "$origsize"
	printf 'gzip: %d bytes (%2.2f%%)\n' "$gzipsize" "$ratio"
}
function json() {
	if which -s jq && ! which -s pygmentize; then
		if [ -t 0 ]; then
			jq '.' <<< "$*"
		else
			jq '.' -
		fi
	else
		if [ -t 0 ]; then
			python -mjson.tool <<< "$*" | pygmentize -l javascript
		else
			python -mjson.tool | pygmentize -l javascript
		fi
	fi
}
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}
function mwiki() {
	dig +short txt "$*".wp.dg.cx
}
function escape() {
	local args
	mapfile -t args < <(printf "%s" "$*" | xxd -p -c1 -u)
	printf '\\x%s' "${args[@]}"
	if [ -t 1 ]; then
		echo ""
	fi
}
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$*\""
	if [ -t 1 ]; then
		echo ""
	fi
}
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$*\"))"
	if [ -t 1 ]; then
		echo ""
	fi
}
function v() {
	if [ $# -eq 0 ]; then
		vim .
	else
		vim "$@"
	fi
}
if [[ "$(uname -s)" == "Linux" ]]; then
	alias open="xdg-open"
fi
function o() {
	if (($# > 0)); then
		open "@" > /dev/null 2>&1
	else
		open . > /dev/null 2>&1
	fi
}
function l() {
	local path cmd
	path=.
	cmd=less
	if (($# > 0)); then
		if [[ $1 =~ ^[-]{0,2}((vs)?c(ode)?|vs?)$ ]]; then
			cmd='code'
			shift 1
		elif [[ $1 =~ ^[-]{0,2}(p(rint)?|cat)$ ]]; then
			cmd='cat'
			shift 1
		elif [[ $1 =~ ^[-]{0,2}(less|more|nvim|vim)$ ]]; then
			cmd=${BASH_REMATCH[1]:-less}
			shift 1
		elif [[ $1 =~ ^[-]{0,2}(o(pen)?)$ ]]; then
			cmd='open'
			shift 1
		fi
		[ -e "$1" ] && {
			path="${1-}"
			shift 1
		}
	fi
	if [ -d "${path:-.}" ]; then
		command ls -FAgoHhksG "$@" "${path:-.}"
	elif [ -r "${path-}" ] && [ -f "${path-}" ]; then
		${cmd:-less} "$@" "${path:-.}"
	fi
}
function tre() {
	tree -aC -I '.git' --dirsfirst "$@" | less -FRNX
}
function gitrepo() {
	local base_url
	base_url=$(git config --get remote.origin.url)
	base_url=${base_url%\.git}
	base_url=${base_url//git@github\.com:/https:\/\/github\.com\/}
	base_url=${base_url//git:\/\/github\.com/https:\/\/github\.com\/}
	base_url=${base_url//git@bitbucket.org:/https:\/\/bitbucket\.org\/}
	base_url=${base_url//git@gitlab\.com:/https:\/\/gitlab\.com\/}
	if ! git branch 2> /dev/null 1>&2; then
		echo "Not a git repo!"
		exit $?
	fi
	full_path=$(pwd)
	git_base_path=$(
		cd "./$(git rev-parse --show-cdup)" || exit 1
		pwd
	)
	relative_path="${full_path#"$git_base_path"}"
	if [ -n "$1" ]; then
		relative_path="$relative_path/$1"
	fi
	git_where=$(command git name-rev --name-only --no-undefined --always HEAD) 2> /dev/null
	branch="${git_where#refs\/heads\/}"
	[[ $base_url == *bitbucket* ]] && tree="src" || tree="tree"
	url="$base_url/$tree/$branch$relative_path"
	echo "Calling $(type open) for $url"
	open "$url" &> /dev/null || (echo "Using $(type open) to open URL failed." && exit 1)
}
function __mancolors() {
	env \
		LESS_TERMCAP_mb="$(printf '\e[1;31m')" \
		LESS_TERMCAP_md="$(printf '\e[1;31m')" \
		LESS_TERMCAP_me="$(printf '\e[0m')" \
		LESS_TERMCAP_se="$(printf '\e[0m')" \
		LESS_TERMCAP_so="$(printf '\e[1;44;33m')" \
		LESS_TERMCAP_ue="$(printf '\e[0m')" \
		LESS_TERMCAP_us="$(printf '\e[1;32m')" \
		man "$@"
}
alias man=__mancolors
function __lesscolors() {
	env \
		LESS_TERMCAP_mb="$(printf '\e[1;31m')" \
		LESS_TERMCAP_md="$(printf '\e[1;31m')" \
		LESS_TERMCAP_me="$(printf '\e[0m')" \
		LESS_TERMCAP_se="$(printf '\e[0m')" \
		LESS_TERMCAP_so="$(printf '\e[1;44;33m')" \
		LESS_TERMCAP_ue="$(printf '\e[0m')" \
		LESS_TERMCAP_us="$(printf '\e[1;32m')" \
		less "$@"
}
alias less=__lesscolors
function __morecolors() {
	env \
		LESS_TERMCAP_mb="$(printf '\e[1;31m')" \
		LESS_TERMCAP_md="$(printf '\e[1;31m')" \
		LESS_TERMCAP_me="$(printf '\e[0m')" \
		LESS_TERMCAP_se="$(printf '\e[0m')" \
		LESS_TERMCAP_so="$(printf '\e[1;44;33m')" \
		LESS_TERMCAP_ue="$(printf '\e[0m')" \
		LESS_TERMCAP_us="$(printf '\e[1;32m')" \
		more --use-color "$@"
}
alias more=__morecolors
function get_var() {
	eval 'printf "%s\n" "${'"$1"'}"'
}
function set_var() {
	eval "$1=\"\$2\""
}
function dedupe_path() {
	local pathvar_value deduped_path
	pathvar_value="${1:-$PATH}"
	deduped_path="$(perl -e 'print join(":",grep { not $seen{$_}++ } split(/:/, $ARGV[0]))' "$pathvar_value")"
	echo -n "$deduped_path" && return 0
	return 1
}
